/* packages/cli/core/src/codegen/typescript.rs */

use std::collections::BTreeMap;

use anyhow::{Context, Result};
use serde_json::Value;

use crate::manifest::Manifest;

/// Generate a typed TypeScript client from a manifest.
pub fn generate_typescript(manifest: &Manifest) -> Result<String> {
  let mut out = String::new();
  out.push_str("// Auto-generated by seam-cli. Do not edit.\n");
  out.push_str("import { createClient } from \"@canmi/seam-client\";\n");
  out.push_str("import type { SeamClient } from \"@canmi/seam-client\";\n\n");

  let mut iface_lines: Vec<String> = Vec::new();
  let mut factory_lines: Vec<String> = Vec::new();

  for (name, schema) in &manifest.procedures {
    let pascal = capitalize(name);

    let input_name = format!("{pascal}Input");
    let output_name = format!("{pascal}Output");

    let input_decl = render_top_level(&input_name, &schema.input)?;
    let output_decl = render_top_level(&output_name, &schema.output)?;

    out.push_str(&input_decl);
    out.push('\n');
    out.push_str(&output_decl);
    out.push('\n');

    iface_lines.push(format!("  {name}(input: {input_name}): Promise<{output_name}>;"));
    factory_lines.push(format!(
      "    {name}: (input) => client.call(\"{name}\", input) as Promise<{output_name}>,"
    ));
  }

  out.push_str("export interface SeamProcedures {\n");
  for line in &iface_lines {
    out.push_str(line);
    out.push('\n');
  }
  out.push_str("}\n\n");

  out.push_str("export function createSeamClient(baseUrl: string): SeamProcedures {\n");
  out.push_str("  const client: SeamClient = createClient({ baseUrl });\n");
  out.push_str("  return {\n");
  for line in &factory_lines {
    out.push_str(line);
    out.push('\n');
  }
  out.push_str("  };\n");
  out.push_str("}\n");

  Ok(out)
}

/// Render a top-level named type declaration.
/// Properties form -> `export interface`, other forms -> `export type`.
fn render_top_level(name: &str, schema: &Value) -> Result<String> {
  if is_properties_form(schema) {
    render_interface(name, schema)
  } else {
    let ts = render_type(schema).with_context(|| format!("rendering type for {name}"))?;
    Ok(format!("export type {name} = {ts};\n"))
  }
}

/// Render a JTD properties-form schema as a TypeScript interface.
fn render_interface(name: &str, schema: &Value) -> Result<String> {
  let nullable = schema.get("nullable").and_then(|v| v.as_bool()).unwrap_or(false);
  let mut out = String::new();

  out.push_str(&format!("export interface {name} {{\n"));

  if let Some(props) = schema.get("properties").and_then(|v| v.as_object()) {
    let sorted: BTreeMap<_, _> = props.iter().collect();
    for (key, val) in sorted {
      let ts = render_type(val)?;
      out.push_str(&format!("  {key}: {ts};\n"));
    }
  }

  if let Some(opt_props) = schema.get("optionalProperties").and_then(|v| v.as_object()) {
    let sorted: BTreeMap<_, _> = opt_props.iter().collect();
    for (key, val) in sorted {
      let ts = render_type(val)?;
      out.push_str(&format!("  {key}?: {ts};\n"));
    }
  }

  out.push_str("}\n");

  if nullable {
    // Wrap as type alias instead
    return Ok(
      format!("export type {name} = {name}Inner | null;\n\nexport interface {name}Inner {{\n")
        + &out[format!("export interface {name} {{\n").len()..],
    );
  }

  Ok(out)
}

/// Recursively render a JTD schema as a TypeScript type expression.
fn render_type(schema: &Value) -> Result<String> {
  let nullable = schema.get("nullable").and_then(|v| v.as_bool()).unwrap_or(false);
  let inner = render_type_inner(schema)?;

  if nullable {
    Ok(format!("{inner} | null"))
  } else {
    Ok(inner)
  }
}

fn render_type_inner(schema: &Value) -> Result<String> {
  let obj = match schema.as_object() {
    Some(o) => o,
    None => anyhow::bail!("schema must be a JSON object"),
  };

  // Empty form (only nullable key or truly empty)
  let meaningful_keys: Vec<_> = obj.keys().filter(|k| *k != "nullable").collect();
  if meaningful_keys.is_empty() {
    return Ok("unknown".to_string());
  }

  // Type form
  if let Some(t) = obj.get("type").and_then(|v| v.as_str()) {
    return Ok(jtd_type_to_ts(t).to_string());
  }

  // Enum form
  if let Some(variants) = obj.get("enum").and_then(|v| v.as_array()) {
    let parts: Vec<String> =
      variants.iter().filter_map(|v| v.as_str()).map(|s| format!("\"{s}\"")).collect();
    return Ok(parts.join(" | "));
  }

  // Elements form
  if let Some(elem) = obj.get("elements") {
    let inner = render_type(elem)?;
    return Ok(format!("Array<{inner}>"));
  }

  // Values form
  if let Some(val) = obj.get("values") {
    let inner = render_type(val)?;
    return Ok(format!("Record<string, {inner}>"));
  }

  // Discriminator form
  if let Some(tag) = obj.get("discriminator").and_then(|v| v.as_str()) {
    if let Some(mapping) = obj.get("mapping").and_then(|v| v.as_object()) {
      let sorted: BTreeMap<_, _> = mapping.iter().collect();
      let parts: Vec<String> = sorted
        .iter()
        .map(|(key, variant)| {
          let variant_ts = render_type(variant)?;
          Ok(format!("({{ {tag}: \"{key}\" }} & {variant_ts})"))
        })
        .collect::<Result<Vec<_>>>()?;
      return Ok(parts.join(" | "));
    }
  }

  // Properties form
  if is_properties_form(schema) {
    return render_inline_object(schema);
  }

  // Ref form (not used in v0.1.0, but handle gracefully)
  if let Some(r) = obj.get("ref").and_then(|v| v.as_str()) {
    return Ok(r.to_string());
  }

  anyhow::bail!("unrecognized JTD schema form: {schema}")
}

fn render_inline_object(schema: &Value) -> Result<String> {
  let mut fields = Vec::new();

  if let Some(props) = schema.get("properties").and_then(|v| v.as_object()) {
    let sorted: BTreeMap<_, _> = props.iter().collect();
    for (key, val) in sorted {
      let ts = render_type(val)?;
      fields.push(format!("{key}: {ts}"));
    }
  }

  if let Some(opt_props) = schema.get("optionalProperties").and_then(|v| v.as_object()) {
    let sorted: BTreeMap<_, _> = opt_props.iter().collect();
    for (key, val) in sorted {
      let ts = render_type(val)?;
      fields.push(format!("{key}?: {ts}"));
    }
  }

  Ok(format!("{{ {} }}", fields.join("; ")))
}

fn is_properties_form(schema: &Value) -> bool {
  schema.get("properties").is_some() || schema.get("optionalProperties").is_some()
}

fn jtd_type_to_ts(t: &str) -> &str {
  match t {
    "string" | "timestamp" => "string",
    "boolean" => "boolean",
    "int8" | "int16" | "int32" | "uint8" | "uint16" | "uint32" | "float32" | "float64" => "number",
    _ => "unknown",
  }
}

fn capitalize(s: &str) -> String {
  let mut chars = s.chars();
  match chars.next() {
    Some(c) => c.to_uppercase().to_string() + chars.as_str(),
    None => String::new(),
  }
}

#[cfg(test)]
mod tests {
  use serde_json::json;

  use super::*;

  #[test]
  fn primitive_string() {
    let schema = json!({ "type": "string" });
    assert_eq!(render_type(&schema).unwrap(), "string");
  }

  #[test]
  fn primitive_boolean() {
    let schema = json!({ "type": "boolean" });
    assert_eq!(render_type(&schema).unwrap(), "boolean");
  }

  #[test]
  fn primitive_numbers() {
    for t in &["int8", "int16", "int32", "uint8", "uint16", "uint32", "float32", "float64"] {
      let schema = json!({ "type": t });
      assert_eq!(render_type(&schema).unwrap(), "number", "failed for {t}");
    }
  }

  #[test]
  fn primitive_timestamp() {
    let schema = json!({ "type": "timestamp" });
    assert_eq!(render_type(&schema).unwrap(), "string");
  }

  #[test]
  fn properties_required_and_optional() {
    let schema = json!({
        "properties": {
            "name": { "type": "string" },
            "age": { "type": "int32" }
        },
        "optionalProperties": {
            "email": { "type": "string" }
        }
    });
    let ts = render_type(&schema).unwrap();
    assert_eq!(ts, "{ age: number; name: string; email?: string }");
  }

  #[test]
  fn elements() {
    let schema = json!({ "elements": { "type": "string" } });
    assert_eq!(render_type(&schema).unwrap(), "Array<string>");
  }

  #[test]
  fn values_form() {
    let schema = json!({ "values": { "type": "float64" } });
    assert_eq!(render_type(&schema).unwrap(), "Record<string, number>");
  }

  #[test]
  fn enum_form() {
    let schema = json!({ "enum": ["PENDING", "ACTIVE", "DISABLED"] });
    assert_eq!(render_type(&schema).unwrap(), "\"PENDING\" | \"ACTIVE\" | \"DISABLED\"");
  }

  #[test]
  fn discriminator_form() {
    let schema = json!({
        "discriminator": "type",
        "mapping": {
            "email": {
                "properties": { "address": { "type": "string" } }
            },
            "sms": {
                "properties": { "phone": { "type": "string" } }
            }
        }
    });
    let ts = render_type(&schema).unwrap();
    assert_eq!(
      ts,
      "({ type: \"email\" } & { address: string }) | ({ type: \"sms\" } & { phone: string })"
    );
  }

  #[test]
  fn nullable_primitive() {
    let schema = json!({ "type": "string", "nullable": true });
    assert_eq!(render_type(&schema).unwrap(), "string | null");
  }

  #[test]
  fn nullable_elements() {
    let schema = json!({ "elements": { "type": "int32" }, "nullable": true });
    assert_eq!(render_type(&schema).unwrap(), "Array<number> | null");
  }

  #[test]
  fn empty_schema() {
    let schema = json!({});
    assert_eq!(render_type(&schema).unwrap(), "unknown");
  }

  #[test]
  fn nested_properties() {
    let schema = json!({
        "properties": {
            "user": {
                "properties": {
                    "name": { "type": "string" },
                    "id": { "type": "uint32" }
                }
            }
        }
    });
    let ts = render_type(&schema).unwrap();
    assert_eq!(ts, "{ user: { id: number; name: string } }");
  }

  #[test]
  fn full_manifest_render() {
    let manifest = Manifest {
      version: "0.1.0".to_string(),
      procedures: {
        let mut m = BTreeMap::new();
        m.insert(
          "greet".to_string(),
          crate::manifest::ProcedureSchema {
            input: json!({
                "properties": { "name": { "type": "string" } }
            }),
            output: json!({
                "properties": { "message": { "type": "string" } }
            }),
          },
        );
        m
      },
    };

    let code = generate_typescript(&manifest).unwrap();
    assert!(code.contains("export interface GreetInput {"));
    assert!(code.contains("  name: string;"));
    assert!(code.contains("export interface GreetOutput {"));
    assert!(code.contains("  message: string;"));
    assert!(code.contains("greet(input: GreetInput): Promise<GreetOutput>;"));
    assert!(
      code.contains("greet: (input) => client.call(\"greet\", input) as Promise<GreetOutput>,")
    );
  }

  #[test]
  fn top_level_non_properties_uses_type_alias() {
    let ts = render_top_level(
      "ListUsersOutput",
      &json!({
          "elements": {
              "properties": {
                  "id": { "type": "uint32" },
                  "name": { "type": "string" }
              }
          }
      }),
    )
    .unwrap();
    assert!(ts.starts_with("export type ListUsersOutput = Array<"));
  }

  #[test]
  fn top_level_properties_uses_interface() {
    let ts = render_top_level(
      "GreetInput",
      &json!({
          "properties": { "name": { "type": "string" } }
      }),
    )
    .unwrap();
    assert!(ts.starts_with("export interface GreetInput {"));
  }
}
