/* packages/cli/core/src/codegen/typescript/generator.rs */

use anyhow::Result;

use crate::build::rpc_hash::RpcHashMap;
use crate::manifest::{Manifest, ProcedureType};

use super::render::{capitalize, render_top_level};

/// Generate a typed TypeScript client from a manifest.
pub fn generate_typescript(
  manifest: &Manifest,
  rpc_hashes: Option<&RpcHashMap>,
  data_id: &str,
) -> Result<String> {
  let mut out = String::new();
  out.push_str("// Auto-generated by seam. Do not edit.\n");

  out.push_str("import { createClient } from \"@canmi/seam-client\";\n");
  out.push_str(
    "import type { SeamClient, SeamClientError, ProcedureKind, Unsubscribe } from \"@canmi/seam-client\";\n\n",
  );

  out.push_str(&format!("export const DATA_ID = \"{}\";\n\n", data_id));

  let mut iface_lines: Vec<String> = Vec::new();
  let mut factory_lines: Vec<String> = Vec::new();

  for (name, schema) in &manifest.procedures {
    let pascal = capitalize(name);
    let is_subscription = schema.proc_type == ProcedureType::Subscription;

    let input_name = format!("{pascal}Input");
    let output_name = format!("{pascal}Output");

    let input_decl = render_top_level(&input_name, &schema.input)?;
    let output_decl = render_top_level(&output_name, &schema.output)?;

    out.push_str(&input_decl);
    out.push('\n');
    out.push_str(&output_decl);
    out.push('\n');

    if let Some(ref error_schema) = schema.error {
      let error_name = format!("{pascal}Error");
      let error_decl = render_top_level(&error_name, error_schema)?;
      out.push_str(&error_decl);
      out.push('\n');
    }

    let wire_name =
      rpc_hashes.and_then(|m| m.procedures.get(name)).map(|h| h.as_str()).unwrap_or(name.as_str());

    if is_subscription {
      iface_lines.push(format!(
        "  {name}(input: {input_name}, onData: (data: {output_name}) => void, onError?: (err: SeamClientError) => void): Unsubscribe;"
      ));
      factory_lines.push(format!(
        "    {name}: (input, onData, onError) => client.subscribe(\"{wire_name}\", input, onData as (data: unknown) => void, onError),"
      ));
    } else {
      let method = match schema.proc_type {
        ProcedureType::Command => "command",
        _ => "query",
      };
      iface_lines.push(format!("  {name}(input: {input_name}): Promise<{output_name}>;"));
      factory_lines.push(format!(
        "    {name}: (input) => client.{method}(\"{wire_name}\", input) as Promise<{output_name}>,"
      ));
    }
  }

  out.push_str("export interface SeamProcedures {\n");
  for line in &iface_lines {
    out.push_str(line);
    out.push('\n');
  }
  out.push_str("}\n\n");

  // SeamProcedureMeta type map
  out.push_str("export interface SeamProcedureMeta {\n");
  for (name, schema) in &manifest.procedures {
    let pascal = capitalize(name);
    let kind = match schema.proc_type {
      ProcedureType::Query => "query",
      ProcedureType::Command => "command",
      ProcedureType::Subscription => "subscription",
    };
    let input_name = format!("{pascal}Input");
    let output_name = format!("{pascal}Output");
    if schema.error.is_some() {
      let error_name = format!("{pascal}Error");
      out.push_str(&format!(
        "  {name}: {{ kind: \"{kind}\"; input: {input_name}; output: {output_name}; error: {error_name} }};\n"
      ));
    } else {
      out.push_str(&format!(
        "  {name}: {{ kind: \"{kind}\"; input: {input_name}; output: {output_name} }};\n"
      ));
    }
  }
  out.push_str("}\n\n");

  if let Some(map) = rpc_hashes {
    out.push_str("export function createSeamClient(baseUrl: string): SeamProcedures {\n");
    out.push_str(&format!(
      "  const client: SeamClient = createClient({{ baseUrl, batchEndpoint: \"{}\" }});\n",
      map.batch
    ));
  } else {
    out.push_str("export function createSeamClient(baseUrl: string): SeamProcedures {\n");
    out.push_str("  const client: SeamClient = createClient({ baseUrl });\n");
  }
  out.push_str("  return {\n");
  for line in &factory_lines {
    out.push_str(line);
    out.push('\n');
  }
  out.push_str("  };\n");
  out.push_str("}\n");

  Ok(out)
}
